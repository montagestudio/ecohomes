{
  "name": "collections",
  "version": "0.0.13",
  "description": "data structures with idiomatic JavaScript collection interfaces",
  "homepage": "http://github.com/kriskowal/collections",
  "author": {
    "name": "Kris Kowal",
    "email": "kris@cixar.com",
    "url": "http://github.com/kriskowal/collections"
  },
  "keywords": [
    "collections",
    "data structures",
    "observable",
    "list",
    "set",
    "map",
    "splay"
  ],
  "bugs": {
    "url": "http://github.com/kriskowal/collections/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/kriskowal/collections/raw/master/LICENSE"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/kriskowal/collections.git"
  },
  "dependencies": {},
  "devDependencies": {
    "jasmine-node": "*"
  },
  "scripts": {
    "test": "jasmine-node spec"
  },
  "readme": "[![build status](https://secure.travis-ci.org/kriskowal/collections.png)](http://travis-ci.org/kriskowal/collections)\n\n# Collections\n\nThis package contains JavaScript implementations of common data\nstructures with idiomatic iterfaces, including extensions for Array and\nObject.\n\n-   **List(values, equals, content)**\n\n    An ordered collection of values with fast insertion and deletion and\n    forward and backward traversal, backed by a cyclic doubly linked\n    list with a head node.  Lists support most of the Array interface,\n    except that they use and return nodes instead of integer indicies in\n    analogous functions.\n\n-   **Set(values, equals, hash, content)**\n\n    A collection of unique values.  The set can be iterated in the order\n    of insertion.  With a good hash function for the stored values,\n    insertion and removal are fast regardless of the size of the\n    collection.  Values may be objects.  The `equals` and `hash`\n    functions can be overridden to provide alternate definitions of\n    \"unique\".  `Set` is backed by `FastSet` and `List`.\n\n-   **Map(map, equals, hash, content)**\n\n    A collection of key and value items with unique keys.  Keys may be\n    objects.  The collection iterates in the order of insertion.  `Map`\n    is backed by `Set`.\n\n-   **MultiMap(map, content, equals, hash)**\n\n    A collection of keys mapped to collections of values.  The default\n    `content` collection is an `Array`, but it can be a `List` or any\n    other array-like object.  `MultiMap` inherits `Map` but overrides\n    the `content` constructor.\n\n-   **WeakMap()**\n\n    A non-iterable collection of key value pairs.  Keys must objects and\n    do not benefit from `hash` functions.  Some engines already\n    implement `WeakMap`.  The non-iterable requirement makes it possible\n    for weak maps to collect garbage when the key is no longer\n    available, without betraying when the key is collected.  The shimmed\n    implementation undetectably annotates the given key and thus does\n    not necessarily leak memory, but cannot collect certain reference\n    graphs.  This WeakMap shim was implemented by Mark Miller of Google.\n\n-   **SortedSet(values, equals, compare, content)**\n\n    A collection of unique values stored in stored order, backed by a\n    splay tree.  The `equals` and `compare` functions can be overridden\n    to provide alternate definitions of \"unique\".\n\n-   **SortedMap(map, equals, compare, content)**\n\n    A collection of key value pairs stored in sorted order.  `SortedMap`\n    is backed by `SortedSet` and the `GenericMap` mixin.\n\n-   **LruSet(values, maxLength, equals, hash, content)**\n\n    A cache with the Least-Recently-Used strategy for truncating its\n    content when it’s length exceeds `maxLength`.  `LruSet` is backed by\n    a `Set` and takes advantage of the already tracked insertion order.\n    Both getting and setting a value constitute usage, but checking\n    whether the set has a value and iterating values do not.\n\n-   **LruMap(map, maxLength, equals, hash, content)**\n\n    A cache of items backed by an `LruSet`.\n\n-   **SortedArray(values, equals, compare, content)**\n\n    A collection of values stored in a stable sorted order, backed by an\n    array.\n\n-   **SortedArraySet(values, equals, compare, content)**\n\n    A collection of unique values stored in sorted order, backed by a\n    plain array.  If the given values are an actual array, the sorted\n    array set takes ownership of that array and retains its content.  A\n    sorted array set performs better than a sorted set when it has\n    roughly less than 100 values.\n\n-   **SortedArrayMap(values, equals, compare, content)**\n\n    A collection of key value pairs stored in sorted order, backed by a\n    sorted array set.\n\n-   **FastSet(values, equals, hash, content)**\n\n    A collection of unique values stored like a hash table.  The\n    underlying storage is a `Dict` that maps hashes to lists of values\n    that share the same hash.  Values may be objects.  The `equals` and\n    `hash` functions can be overridden to provide alternate definitions\n    of \"unique\".\n\n-   **FastMap(map, equals, hash, content)**\n\n    A collection of key and value items with unique keys, backed by a\n    set.  Keys may be objects.  `FastMap` is backed by `FastSet` and the\n    `GenericMap` mixin.\n\n-   **Dict(values, content)**\n\n    A collection of string to value mappings backed by a plain\n    JavaScript object.  The keys are mangled to prevent collisions with\n    JavaScript properties.\n\n-   **Iterator(iterable)**\n\n    A wrapper for any iterable that implements `iterate` or iterator the\n    implements `next`, providing a rich lazy traversal interface.\n\n-   **Array**\n\n    An ordered collection of values with fast random access, push, and\n    pop, but slow splice. The `array` module provides extensions so it\n    hosts all the expressiveness of other collections.  The `array-shim`\n    module shims EcmaScript 5 methods onto the array prototype if they\n    are not natively implemented.\n\n-   **Object**\n\n    Can be used as a mapping of owned string keys to arbitrary values.\n    The `object` module provides extensions for the `Object` constructor\n    that support the map collection interface and can delegate to\n    methods of collections, allowing them to gracefully handle both\n    object literals and collections.\n\n## Constructor Arguments\n\nFor all of these constructors, the argument `values` is an optional\ncollection of initial values, and may be an array.  If the `values` are\nin a map collection, the the values are taken, but the keys are ignored.\n\n-   **map**\n\n    The `map` argument is an optional collection to copy shallowly into\n    the new mapping.  The `map` may be an object literal.  If `map`\n    implements `keys`, it is treated as a mapping itself and copied.\n    Otherwise, if `map` implements `forEach`, it may be any collection\n    of `[key, value]` pairs.\n\n`equals(x, y)`, `compare(x, y)`, and `hash(value)` are all optional\narguments overriding the meaning of equality, comparability, and\nconsistent hashing for the purposes of the collection.  `equals` must\nreturn a boolean.  `compare` must return an integer with the same\nrelationship to zero as x to y.  `hash` should consistently return the\nsame string for any given object.\n\n-   **equals(x, y)**\n\n    The default `equals` operator is implemented in terms of `===`, but\n    treats `NaN` as equal to itself and `-0` as distinct from `+0`.  It\n    also delegates to an `equals` method of either the left or right\n    argument if one exists.  The default equality operator is shimmed as\n    `Object.equals`.\n\n-   **compare(x, y)**\n\n    The default `compare` operator is implemented in terms of `<` and\n    `>`.  It delegates to the `compare` method of either the left or\n    right argument if one exists.  It inverts the result if it uses the\n    falls to the right argument.  The default comparator is shimmed as\n    `Object.compare`.\n\n-   **hash(value)**\n\n    The default `hash` operator uses `toString` for values and provides\n    a [Unique Label][] for arbitrary objects.  The default hash is\n    shimmed as `Object.hash`.\n\n[Unique Label]: (http://wiki.ecmascript.org/doku.php?id=harmony:weak_maps#unique_labeler)\n\n-   **content(key or value)**\n\n    The default `content` function is `Function.noop`, which returns\n    `undefined`.  The content function is used when you `get` a\n    nonexistant value from any collection.  The `content` function\n    becomes a member of the collection object, so `content` is called\n    with the collection as `this`, so you can also use it to guarantee\n    that default values in a collection are retained, as in `MultiMap`.\n\n\n## Collection Methods\n\nWhere these methods coincide with the specification of an existing\nmethod of Array, Array is noted as an implementation.  `Array+` refers\nto shimmed arrays, as installed with the `array` module.  `Object`\nrefers to methods implemented on the `Object` constructor function, as\nopposed to the `Object.prototype`.  `Object+` in turn refers to methods\nshimmed on the object constructor by the `object` module.  These\nfunctions accept the object as the first argument instead of the `this`\nimplied argument.  ~~Strikethrough~~ indicates an implementation that\nshould exist but has not yet been made (Send a pull request!).\n\nThese are all of the collections:\n\n(Array, Array+, Object+, Iterator, List, Set, Map, MultiMap, WeakMap,\nSortedSet, SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict)\n\n-   **has(key)**\n\n    Whether a value for the given key exists.\n\n    (Object+, Map, MultiMap, SortedMap, LruMap, SortedArrayMap, FastMap,\n    Dict)\n\n    **has(value, opt_equals)**\n\n    Whether a value exists in this collection.  This is slow for list\n    (linear), but fast (logarithmic) for SortedSet and SortedArraySet,\n    and very fast (constant) for Set.\n\n    (Array+, List, Set, SortedSet, LruSet, SortedArray, SortedArraySet,\n    FastSet)\n\n-   **get(key or index)**\n\n    The value for a key.  If a Map or SortedMap lacks a key, returns\n    `content(key)`.\n\n    (Array+, Map, SortedMap, SortedArrayMap, WeakMap, Object+)\n\n    **get(value)**\n\n    Gets the equivalent value, or falls back to `content(value)`.\n\n    (List, Set, SortedSet, LruSet, SortedArray, SortedArraySet, FastSet)\n\n-   **set(key or index, value)**\n\n    Sets the value for a key.\n\n    (Map, MultiMap, WeakMap, SortedMap, LruMap, SortedArrayMap, FastMap,\n    Dict)\n\n-   **add(value)**\n\n    Adds a value.  Ignores the operation and returns false if an\n    equivalent value already exists.\n\n    (Array+, List, Set, SortedSet, LruSet, SortedArray, SortedArraySet,\n    FastSet)\n\n-   **addEach(values)**\n\n    Copies values from another collection to this one.\n\n    (Array+, List, Set, SortedSet, LruSet, SortedArray, SortedArraySet,\n    FastSet)\n\n    **addEach(mapping)**\n\n    Copies items from another collection to this map.  If the mapping\n    implements `keys` (indicating that it is a mapping) and `forEach`,\n    all of the key value pairs are copied.  If the mapping only\n    implements `forEach`, it is assumed to contain `[key, value]` arrays\n    which are copied instead.\n\n    (Object+, Map, MultiMap, SortedMap, LruMap, SortedArrayMap, FastMap,\n    Dict)\n\n-   **delete(key)**\n\n    Deletes the value for a given key.  Returns whether the key was\n    found.\n\n    (Map, MultiMap, WeakMap, SortedMap, LruMap, SortedArrayMap, FastMap,\n    Dict)\n\n    **delete(value)**\n\n    Deletes a value.  Returns whether the value was found.\n\n    (Array+, List, Set, SortedSet, LruSet, SortedArray, SortedArraySet,\n    FastSet)\n\n-   **deleteEach(values or keys)**\n\n    Deletes every value or every value for each key.\n\n    (Array+, List, Set, Map, MultiMap, WeakMap, SortedSet, SortedMap,\n    LruSet, LruMap, SortedArray, SortedArraySet, SortedArrayMap,\n    FastSet, FastMap, Dict)\n\n-   **indexOf(value)**\n\n    Returns the position in the collection of a value, or `-1` if it is\n    not found.  Returns the position of the first of equivalent values.\n    For an Array this takes linear time.  For a SortedArray and\n    SortedArraySet, it takes logarithmic time to perform a binary\n    search.  For a SortedSet, this takes ammortized logarithmic time\n    since it incrementally updates the number of nodes under each\n    subtree as it rotates.\n\n    (Array, ~~List~~, SortedSet, SortedArray, SortedArraySet)\n\n-   **lastIndexOf(value)**\n\n    Returns the position in the collection of a value, or `-1` if it is\n    not found.  Returns the position of the last of equivalent values.\n\n    (Array, ~~List~~, SortedArray, SortedArraySet)\n\n-   **find(value, opt_equals)**\n\n    Finds a value.  For List and SortedSet, returns the node at which\n    the value was found.  For SortedSet, the optional `equals` argument\n    is ignored.\n\n    (Array+, List, SortedSet)\n\n-   **findLast(value, opt_equals)**\n\n    Finds the last equivalent value, returning the node at which the\n    value was found.\n\n    (Array+, List, SortedArray, SortedArraySet)\n\n-   **findLeast()**\n\n    Finds the smallest value, returning the node at which it was found,\n    or undefined.  This is fast (logarithmic) and performs no rotations.\n\n    (SortedSet)\n\n-   **findLeastGreaterThan(value)**\n\n    Finds the smallest value greater than the given value.  This is fast\n    (logarithic) but does cause rotations.\n\n    (SortedSet)\n\n-   **findLeastGreaterThanOrEqual(value)**\n\n    Finds the smallest value greater than or equal to the given value.\n    This is fast (logarithmic) but does cause rotations.\n\n    (SortedSet)\n\n-   **findGreatest()**\n\n    (SortedSet)\n\n-   **findGreatestLessThan(value)**\n\n    (SortedSet)\n\n-   **findGreatestLessThanOrEqual(value)**\n\n    (SortedSet)\n\n-   **push(...values)**\n\n    Adds values to the end of a collection.\n\n    (Array, List)\n\n    **push(...values)** for non-dequeues\n\n    Adds values to their proper places in a collection.\n    This method exists only to have the same interface as other\n    collections.\n\n    (Set, SortedSet, LruSet, SortedArray, SortedArraySet, FastSet)\n\n-   **unshift(...values)**\n\n    Adds values to the beginning of a collection.\n\n    (Array, List)\n\n    **unshift(...values)** for non-dequeues\n\n    Adds values to their proper places in a collection.\n    This method exists only to have the same interface as other\n    collections.\n\n    (Set, SortedSet, LruSet, SortedArray, SortedArraySet, FastSet)\n\n-   **pop()**\n\n    Removes and returns the value at the end of a collection.\n\n    (Array, List, Set, SortedSet, LruSet, SortedArray, SortedArraySet)\n\n-   **shift()**\n\n    Removes and returns the value at the beginning of a collection.\n\n    (Array, List, Set, SortedSet, LruSet, SortedArray, SortedArraySet)\n\n-   **slice(start, end)**\n\n    Returns an array of the values contained in the\n    half-open interval [start, end), that is, including the start and\n    excluding the end.  For lists and arrays, both terms may be numeric\n    positive or negative indicies.  For a list, either term may be a\n    node.\n\n    (Array, List, SortedSet, SortedArray, SortedArraySet)\n\n-   **splice(start, length, ...values)**\n\n    Works as with an array, but for a list, the start may be an index or\n    a node.\n\n    (Array, List, SortedArray, SortedSet, SortedArraySet)\n\n-   **swap(start, length, values)**\n\n    Performs a splice without variadic arguments.\n\n    (Array+, List, SortedArray, SortedSet, SortedArraySet)\n\n-   **clear()**\n\n    Deletes the all values.\n\n    (Array+, Object+, List, Set, Map, MultiMap, WeakMap, SortedSet,\n    SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\n    SortedArrayMap, FastSet, FastMap, Dict)\n\n-   **sort(compare)**\n\n    Sorts a collection in place.  The comparator by only be a function.\n    The default comparator coerces unlike types rather than fail to\n    compare.\n\n    (Array)\n\n-   **sorted(compare, by, order)**\n\n    Returns a collection as an array in sorted order.  Accepts an\n    optional `compare(x, y)` function, `by(property(x))` function, and\n    `order` indicator, `-1` for descending, `1` for ascending, `0` for\n    stable.\n\n    Instead of a `compare` function, the comparator can be an object\n    with `compare` and `by` functions.  The default `compare` value is\n    `Object.compare`.\n\n    The `by` function must be a function that accepts a value from the\n    collection and returns a representative value on which to sort.\n\n    (Array+, List, Set, Map, SortedSet, LruSet, SortedArray,\n    SortedArraySet, FastSet)\n\n-   **reverse()**\n\n    Reverses a collection in place.\n\n    (Array, List)\n\n-   **reversed()**\n\n    Returns a collection of the same type with this collection's\n    contents in reverse order.\n\n    (Array, List)\n\n-   **concat(...iterables)**\n\n    Produces a new collection of the same type containing all the values\n    of itself and the values of any number of other collections.  Favors\n    the last of duplicate values.  For map-like objects, the given\n    iterables are treated as map-like objects and each successively\n    updates the result.  Array is like a map from index to value.  List,\n    Set, and SortedSet are like maps from nodes to values.\n\n    (Array, ~~Object+~~, Iterator, List, Set, Map, MultiMap,\n    SortedSet, SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\n    SortedArrayMap, FastSet, FastMap, Dict)\n\n-   **keys()**\n\n    Returns an array of the keys.\n\n    (Object, Map, MultiMap, SortedMap, LruMap, SortedArrayMap, FastMap,\n    Dict)\n\n-   **values()**\n\n    Returns an array of the values\n\n    (Object+, Map, MultiMap, SortedMap, LruMap, SortedArrayMap, FastMap,\n    Dict)\n\n-   **items()**\n\n    Returns an array of `[key, value]` pairs for each item\n\n    (Object+, Map, MultiMap, SortedMap, LruMap, SortedArrayMap, FastMap,\n    Dict)\n\n-   **reduce(callback(result, value, key, object, depth), basis,\n    thisp)**:\n\n    (Array, Iterator, List, Set, Map, MultiMap, SortedSet, SortedMap,\n    LruSet, LruMap, SortedArray, SortedArraySet, SortedArrayMap,\n    FastSet, FastMap, Dict)\n\n-   **reduceRight(callback(result, value, key, object, depth), basis,\n    thisp)**:\n\n    (Array, List, SortedSet, ~~SortedMap~~, SortedArray, SortedArraySet,\n    ~~SortedArrayMap~~)\n\n-   **forEach(callback(value, key, object, depth), thisp)**\n\n    Calls the callback for each value in the collection.  The iteration\n    of lists is resilient to changes to the list.  Particularly, nodes\n    added after the current node will be visited and nodes added before\n    the current node will be ignored, and no node will be visited twice.\n\n    (Array, Object+, Iterator, List, Set, Map, MultiMap, WeakMap,\n    SortedSet, SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\n    SortedArrayMap, FastSet, FastMap, Dict)\n\n-   **map(callback(value, key, object, depth), thisp)**\n\n    (Array, Object+, Iterator, List, Set, Map, MultiMap, WeakMap,\n    SortedSet, SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\n    SortedArrayMap, FastSet, FastMap, Dict)\n\n-   **toArray()**\n\n    (Array+, Iterator, List, Set, Map, MultiMap, SortedSet, SortedMap,\n    LruSet, LruMap, SortedArray, SortedArraySet, SortedArrayMap,\n    FastSet, FastMap, Dict)\n\n-   **toObject()**\n\n    Converts any collection to an object, treating this collection as a\n    map-like object.  Array is like a map from index to value.\n\n    (Array+ Iterator, List, Map, MultiMap, SortedMap, LruMap,\n    SortedArrayMap, FastMap, Dict)\n\n-   **filter(callback(value, key, object, depth), thisp)**\n\n    (Array, Iterator, List, Set, Map, MultiMap, SortedSet, SortedMap,\n    LruSet, LruMap, SortedArray, SortedArraySet, SortedArrayMap,\n    FastSet, FastMap, Dict)\n\n-   **every(callback(value, key, object, depth), thisp)**\n\n    Whether every value passes a given guard.  Stops evaluating the\n    guard after the first failure.  Iterators stop consuming after the\n    the first failure.\n\n    (Array, Iterator, List, Set, Map, MultiMap, SortedSet, SortedMap,\n    LruSet, LruMap, SortedArray, SortedArraySet, SortedArrayMap,\n    FastSet, FastMap, Dict)\n\n-   **some(callback(value, key, object, depth), thisp)**\n\n    Whether there is a value that passes a given guard.  Stops\n    evaluating the guard after the first success.  Iterators stop\n    consuming after the first success.\n\n    (Array, Iterator, List, Set, Map, MultiMap, SortedSet, SortedMap,\n    LruSet, LruMap, SortedArray, SortedArraySet, SortedArrayMap,\n    FastSet, FastMap, Dict)\n\n-   **any()**\n\n    Whether any value is truthy.\n\n    (Array+, Iterator, List, Set, Map, MultiMap, SortedSet, SortedMap,\n    LruSet, LruMap, SortedArray, SortedArraySet, SortedArrayMap,\n    FastSet, FastMap, Dict)\n\n-   **all()**\n\n    Whether all values are truthy.\n\n    (Array+, Iterator, List, Set, Map, MultiMap, SortedSet, SortedMap,\n    LruSet, LruMap, SortedArray, SortedArraySet, SortedArrayMap,\n    FastSet, FastMap, Dict)\n\n-   **min()**\n\n    The smallest value.  This is fast for sorted collections (logarithic\n    for SortedSet, constant for SortedArray, SortedArraySet, and\n    SortedArrayMap), but slow for everything else (linear).\n\n    (Array+, Iterator, List, Set, Map, MultiMap, SortedSet, SortedMap,\n    LruSet, LruMap, SortedArray, SortedArraySet, SortedArrayMap,\n    FastSet, FastMap, Dict)\n\n-   **max()**\n\n    The largest value.  This is fast for sorted collections (logarithic\n    for SortedSet, constant for SortedArray, SortedArraySet, and\n    SortedArrayMap), but slow for everything else (linear).\n\n    (Array+, Iterator, List, Set, Map, MultiMap, SortedSet, SortedMap,\n    LruSet, LruMap, SortedArray, SortedArraySet, SortedArrayMap,\n    FastSet, FastMap, Dict)\n\n-   **one()**\n\n    Any single value, or throws an exception if there are no values.\n    This is very fast (constant) for all collections.  For a sorted set,\n    the value is not deterministic and depends on what value was most\n    recently accessed.\n\n    (Array+, List, Set, Map, MultiMap, SortedSet, SortedMap, LruSet,\n    LruMap, SortedArray, SortedArray, SortedArraySet, SortedArrayMap,\n    FastSet, FastMap, Dict)\n\n-   **only()**\n\n    The one and only value, or throws an exception if there are no\n    values or more than one value.\n\n    (Array+, List, Set, Map, MultiMap, SortedSet, SortedMap, LruSet,\n    LruMap, SortedArray, SortedArray, SortedArraySet, SortedArrayMap,\n    FastSet, FastMap, Dict)\n\n-   **sum()**\n\n    (Array+, Iterator, List, Set, Map, MultiMap, WeakMap, SortedSet,\n    SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\n    SortedArrayMap, FastSet, FastMap, Dict)\n\n-   **average()**\n\n    (Array+, Iterator, List, Set, Map, MultiMap, WeakMap, SortedSet,\n    SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\n    SortedArrayMap, FastSet, FastMap, Dict)\n\n-   **flatten()**\n\n    (Array+, Iterator, List, Set, Map, MultiMap, WeakMap, SortedSet,\n    SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\n    SortedArrayMap, FastSet, FastMap, Dict)\n\n-   **zip(...collections)**\n\n    (Array+, Iterator, List, Set, Map, MultiMap, WeakMap, SortedSet,\n    SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\n    SortedArrayMap, FastSet, FastMap, Dict)\n\n-   **enumrate(zero)**\n\n    (Iterator, ~~other collections~~)\n\n-   **clone(depth, memo)**\n\n    Replicates the collection.  If `Object.clone` is shimmed, clones the\n    values deeply, to the specified depth, using the given memo to\n    resolve reference cycles (which must the `has` and `set` parts of\n    the Map interface, allowing objects for keys)\n\n    (Array+, List, Set, Map, SortedSet, SortedMap, Object+)\n    (Array+, Object+, List, Set, Map, MultiMap, WeakMap, SortedSet,\n    SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\n    SortedArrayMap, FastSet, FastMap, Dict)\n\n-   **constructClone(values)**\n\n    Replicates a collection shallowly.  This is used by each `clone`\n    implementation to create a new collection of the same type, with the\n    same options (`equals`, `compare`, `hash` options), but it leaves\n    the job of deeply cloning the values to the more general `clone`\n    method.\n\n    (Array+, Object+, List, Set, Map, MultiMap, WeakMap, SortedSet,\n    SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\n    SortedArrayMap, FastSet, FastMap, Dict)\n\n-   **equals(that)**\n\n    (Array+, Object+, List, Set, Map, MultiMap, SortedSet, SortedMap,\n    LruSet, LruMap, ~~SortedArray~~, SortedArraySet, SortedArrayMap,\n    FastSet, FastMap, Dict)\n\n-   **compare(that)**\n\n    (~~Array+~~, Object+, ~~List~~, ~~SortedArray~~, ~~SortedArraySet~~)\n\n-   **iterate()**\n\n    Produces an iterator with a `next` method.  You may elect to get\n    richer iterators by wrapping this iterator with an `Iterator` from\n    the `iterator` module.  Iteration order of lists is resilient to\n    changes to the list.\n\n    (Array+, Iterator, List, Set, SortedSet, LruSet, SortedArray,\n    SortedArraySet, FastSet)\n\n    **iterate(start, end)**\n\n    Returns an iterator for all values at indicies in the half-open\n    interval [start, end), that is, greater than start, and less than\n    end.\n\n    (Array+)\n\n    **iterate(start, end)**\n\n    Returns an iterator for all values in the half-open interval [start,\n    end), that is, greater than start, and less than end.  The iterator\n    is resilient against changes to the data.\n\n    (SortedSet)\n\n-   **log(charmap, callback(node, write, writeAbove), log, logger)**\n\n    Writes a tree describing the internal state of the data structure to\n    the console.\n\n    `charmap` is an object that notes which characters to use to draw\n    lines.  By default, this is the `TreeLog.unicodeRound` property from the\n    `tree-log` module.  `TreeLog.unicodeSharp` and `TreeLog.ascii` are\n    alternatives.  The properties are:\n\n    -   intersection: ╋\n    -   through: ━\n    -   branchUp: ┻\n    -   branchDown: ┳\n    -   fromBelow: ╭\n    -   fromAbove: ╰\n    -   fromBoth: ┣\n    -   strafe: ┃\n\n    `callback` is a customizable function for rendering each node of the tree.\n    By default, it just writes the value of the node.  It accepts the node and\n    a writer functions.  The `write` function produces the line on which the\n    node joins the tree, and each subsequent line.  The `writeAbove` function\n    can write lines before the branch.\n\n    `log` and `loger` default to `console.log` and `console`.  To write\n    the representation to an array instead, they can be `array.push` and\n    `array`.\n\n    (SortedSet)\n\n\n### Iterator\n\n-   **dropWhile(callback(value, index, iterator), thisp)**\n\n-   **takeWhile(callback(value, index, iterator), thisp)**\n\n-   **mapIterator(callback(value, index, iterator))**\n\n    Returns an iterator for a mapping on the source values.  Values are\n    consumed on demand.\n\n-   **filterIterator(callback(value, index, iterator))**\n\n    Returns an iterator for those values from the source that pass the\n    given guard.  Values are consumed on demand.\n\n\n### Iterator utilities\n\n-   **cycle(iterable, times)**\n\n-   **concat(iterables)**\n\n-   **transpose(iterables)**\n\n-   **zip(...iterables)**\n\n    Variadic transpose.\n\n-   **chain(...iterables)**\n\n    Variadic concat.\n\n-   **range(start, stop, step)**\n\n    Iterates from start to stop by step.\n\n-   **count(start, step)**\n\n    Iterates from start by step, indefinitely.\n\n-   **repeat(value, times)**\n\n    Repeats the given value either finite times or indefinitely.\n\n\n### Observables\n\n`List`, `Set`, and `SortedSet` can be observed for content changes.\n\nA content change handler can have various forms.  The simplest form is a\nfunction that accepts `plus`, `minus`, and `index` as arguments where\n`plus` is an array of added values, `minus` is an array of deleted\nvalues, and `index` is the position of the change or undefined.  In that\ncase, `this` will be the collection that dispatches the event.\n\nAlternately, you can dispatch events to a handler object.  If the\nhandler has a `handleContentChange` function (for noticing a change\nafter it has occurred) or a `handleContentWillChange` function (for\nnoticing a change before it has occurred), the event will be dispatched\nto one of those.  The function has the same `(plus, minus, index)`\nsignature.\n\nYou can also dispatch change events to a DOM-compatible\n`handleEvent(event)` method, in which case the handler will receive an\nevent with `phase`, `currentTarget`, `target`, `plus`, `minus`, and\n`index` properties.  `phase` is either `\"before\"` or `\"after\"`.  The\ntargets are both the collection in flux.\n\n-   `(plus, minus, index)`\n-   `handleContentChange(plus, minus, index)`\n-   `handleContentWillChange(plus, minus, index)`\n-   `handleEvent({phase, currentTarget, target, plus, minus, index})`\n\nThe methods of the collection for managing content changes are generic,\nin the `observable` module, and have the following forms:\n\n-   `addContentChangeListener(listener, beforeChange)`\n-   `removeContentChangeListener(listener, beforeChange)`\n-   `dispatchContentChange(plus, minus, index)`\n-   `addBeforeContentChangeListener(listener)`\n-   `removeBeforeContentChangeListener(listener)`\n-   `dispatchBeforeContentChange(plus, minus, index)`\n-   `getContentChangeDescriptor()`\n\n\n## List\n\nLists are backed by a cyclic doubly-linked list with a head node.  The\nnodes are returned by \"find\" methods and accepted by \"slice\" and\n\"splice\" as representatives of positions within the list.  Their\nproperties and methods are part of the interface of the structure.\n\n-   `prev`: the previous node, or the `head` of the list if this is the\n    first node\n-   `next`: the next node, or the `head` of the list if this is the last\n    node\n\n\n## Set and Map\n\nSet and map are like hash tables, but not implemented with a block of\nmemory as they would be in a lower-level language.  Most of the work of\nproviding fast insertion and lookup based on a hash is performed by the\nunderlying plain JavaScript object.  Each key of the object is a hash\nstring and each value is a List of values with that hash.  The inner\nlist resolves collisions.  With a good `hash` method, the use of the\nlist can be avoided.\n\nSets and maps both have a `log` function that displays the internal\nstructure of the bucket list in an NPM-style.\n\n```\n┣━┳ 1\n┃ ┗━━ {\"key\":1,\"value\":\"a\"}\n┣━┳ 2\n┃ ┣━━ {\"key\":2,\"value\":\"c\"}\n┃ ┗━━ {\"key\":2,\"value\":\"d\"}\n┗━┳ 3\n  ┗━━ {\"key\":3,\"value\":\"b\"}\n```\n\n\n## Sorted Set and Sorted Map\n\nA binary splay tree is a balanced binary tree that rotates the most\nfrequently used items toward the root such that they can be accessed the\nmost quickly.  `sorted-set` and `sorted-map` are backed by a splay tree.\n\nAll map implementations use an underlying set implementation.  Any map\ncan be implemented trivially atop a set by wrapping `compare`, `equals`,\nor `hash` to operate on the key of an item.\n\nThe sorted set has a `root` node.  Each node has a `left` and `right`\nproperty, which may be null.  Nodes are returned by all of the \"find\"\nfunctions, and provided as the `key` argument to callbacks.\n\nBoth `sorted-set` and `sorted-map` implement a `log` function which can\nproduce NPM-style visualizations of the internal state of the sorted\ntree.\n\n```\n> set.log(SortedSet.ascii)\n  .-+ -3\n  | '-- -2\n.-+ -1\n+ 0\n| .-- 1\n'-+ 2\n  '-- 3\n```\n\n```\n> set.log(SortedSet.unicodeRound)\n  ╭━┳ -3\n  ┃ ╰━━ -2\n╭━┻ -1\n╋ 0\n┃ ╭━┳ 1\n┃ ┃ ╰━━ 2\n╰━┻ 3\n```\n\n\n## Object and Function Shims\n\nThe collection methods on the `Object` constructor all polymorphically\ndefer to the corresponding method of any object that implements the\nmethod of the same name.  So, `Object.has` can be used to check whether\na key exists on an object, or in any collection that implements `has`.\nThis permits the `Object` interface to be agnostic of the input type.\n\n`Object.empty` is an empty object literal.\n\n`Object.isObject(value)` tests whether it is safe to attempt to access\nproperties of a given value.\n\n`Object.is(x, y)` compares objects for exact identity and is a good\nalternative to `Object.equals` in many collections.\n\n`Object.getValueOf(value)` safely and idempotently returns the value of\nan object or value by only calling the `valueOf()` if the value\nimplements that method.\n\n`Object.owns` is a shorthand for `Object.prototype.hasOwnProperty.call`.\n\n`Object.can(value, name)` checks whether an object implements a method\non its prototype chain.  An owned function property does not qualify as\na method, to aid in distinguishing \"static\" functions.\n\n`Function.noop` is returns undefined.\n\n`Function.identity` returns its first argument.\n\n\n## References\n\n- a SplayTree impementation buried in Fedor Indutny’s super-secret\n  [Callgrind](https://github.com/indutny/callgrind.js). This\n  implementation uses parent references.\n- a SplayTree implementation adapted by [Paolo\n  Fragomeni](https://github.com/hij1nx/forest) from the V8 project and\n  based on the top-down splaying algorithm from \"Self-adjusting Binary\n  Search Trees\" by Sleator and Tarjan. This does not use or require\n  parent references, so I favored it over Fedor Indutny’s style.\n- the interface of ECMAScript harmony [simple maps and\n  sets](http://wiki.ecmascript.org/doku.php?id=harmony:simple_maps_and_sets)\n- a SplayTree implementation from [JavaScript data\n  structures](derrickburns/Javascript-Data-Structures) mainted by\n  Derrick Burns that supports change-resilient iterators and a\n  comprehensive set of introspection functions.\n\n## Future work\n\nGoals\n\n- comprehensive specs and spec coverage tests\n- item change dispatch and listeners for Map, SortedMap, FastMap\n- remove iterator dependency of FastSet\n\nMore methods\n\n- equals\n- compare\n- fast list splicing\n- set intersection, union, difference, symmetric difference\n\nMore possible collections\n\n- arc-set (adaptive replacement cache)\n- arc-map\n- sorted-list (sorted, can contain duplicates, perhaps backed by splay\n  tree with relaxation on the uniqueness invariant)\n- sorted-multi-map (sorted, can contain duplicate entries, perhaps\n  backed by sorted-list)\n- string-set (set of strings, backed by a trie)\n- immutable-* (mutation functions return new objects that largely share\n  the previous version's internal state, some perhaps backed by a hash\n  trie)\n- array heap implementation\n- binary heap implementation\n\n",
  "readmeFilename": "README.md",
  "_id": "collections@0.0.13",
  "_from": "collections@~0.0.0"
}
